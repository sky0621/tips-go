// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package rdb

import (
	"context"
	"database/sql"
)

const getContentWithProgramsById = `-- name: GetContentWithProgramsById :many
SELECT
    c.id AS content_id,
    c.name AS content_name,
    p.id AS program_id,
    p.question AS question,
    p.answer AS answer
FROM
    contents AS c
        lEFT JOIN programs AS p ON p.content_id = c.id
WHERE
    c.id = UUID_TO_BIN(?)
`

type GetContentWithProgramsByIdRow struct {
	ContentID   []byte
	ContentName string
	ProgramID   []byte
	Question    sql.NullString
	Answer      sql.NullString
}

func (q *Queries) GetContentWithProgramsById(ctx context.Context, uuidTOBIN string) ([]GetContentWithProgramsByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getContentWithProgramsById, uuidTOBIN)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContentWithProgramsByIdRow{}
	for rows.Next() {
		var i GetContentWithProgramsByIdRow
		if err := rows.Scan(
			&i.ContentID,
			&i.ContentName,
			&i.ProgramID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContentsWithPrograms = `-- name: ListContentsWithPrograms :many
SELECT
    c.id AS content_id,
    c.name AS content_name,
    p.id AS program_id,
    p.question AS question,
    p.answer AS answer
FROM
    contents AS c
        LEFT JOIN programs AS p ON p.content_id = c.id
`

type ListContentsWithProgramsRow struct {
	ContentID   []byte
	ContentName string
	ProgramID   []byte
	Question    sql.NullString
	Answer      sql.NullString
}

func (q *Queries) ListContentsWithPrograms(ctx context.Context) ([]ListContentsWithProgramsRow, error) {
	rows, err := q.db.QueryContext(ctx, listContentsWithPrograms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContentsWithProgramsRow{}
	for rows.Next() {
		var i ListContentsWithProgramsRow
		if err := rows.Scan(
			&i.ContentID,
			&i.ContentName,
			&i.ProgramID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchContentsWithPrograms = `-- name: SearchContentsWithPrograms :many
SELECT
    c.id AS content_id,
    c.name AS content_name,
    p.id AS program_id,
    p.question AS question,
    p.answer AS answer
FROM
    contents AS c
        lEFT JOIN programs AS p ON p.content_id = c.id
WHERE
    c.name LIKE ?
`

type SearchContentsWithProgramsRow struct {
	ContentID   []byte
	ContentName string
	ProgramID   []byte
	Question    sql.NullString
	Answer      sql.NullString
}

func (q *Queries) SearchContentsWithPrograms(ctx context.Context, name string) ([]SearchContentsWithProgramsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchContentsWithPrograms, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchContentsWithProgramsRow{}
	for rows.Next() {
		var i SearchContentsWithProgramsRow
		if err := rows.Scan(
			&i.ContentID,
			&i.ContentName,
			&i.ProgramID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
