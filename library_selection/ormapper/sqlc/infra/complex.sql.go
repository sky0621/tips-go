// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: complex.sql

package infra

import (
	"context"
	"database/sql"
	"time"
)

const listUserWithPostAndComments = `-- name: ListUserWithPostAndComments :many
SELECT
    users.id AS user_id,
    users.name AS user_name,
    users.created_at AS user_created_at,
    users.updated_at AS user_updated_at,
    posts.id AS post_id,
    posts.title AS post_title,
    posts.content AS post_content,
    posts.created_at AS post_created_at,
    posts.updated_at AS post_updated_at,
    comments.id AS comment_id,
    comments.content AS comment_content,
    comments.created_at AS comment_created_at,
    comments.updated_at AS comment_updated_at
FROM users
INNER JOIN posts ON posts.user_id = users.id
INNER JOIN comments ON comments.user_id = users.id AND comments.post_id = posts.id
`

type ListUserWithPostAndCommentsRow struct {
	UserID           int64
	UserName         string
	UserCreatedAt    time.Time
	UserUpdatedAt    time.Time
	PostID           int64
	PostTitle        string
	PostContent      sql.NullString
	PostCreatedAt    time.Time
	PostUpdatedAt    time.Time
	CommentID        int64
	CommentContent   sql.NullString
	CommentCreatedAt time.Time
	CommentUpdatedAt time.Time
}

func (q *Queries) ListUserWithPostAndComments(ctx context.Context) ([]ListUserWithPostAndCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserWithPostAndComments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserWithPostAndCommentsRow{}
	for rows.Next() {
		var i ListUserWithPostAndCommentsRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserName,
			&i.UserCreatedAt,
			&i.UserUpdatedAt,
			&i.PostID,
			&i.PostTitle,
			&i.PostContent,
			&i.PostCreatedAt,
			&i.PostUpdatedAt,
			&i.CommentID,
			&i.CommentContent,
			&i.CommentCreatedAt,
			&i.CommentUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWithComplexQuery = `-- name: ListWithComplexQuery :many
WITH
    c AS (SELECT id, content, user_id, post_id, created_at, updated_at FROM comments WHERE comments.user_id = ?),
    p AS (SELECT id, title, content, user_id, created_at, updated_at FROM posts WHERE posts.user_id = ?)
SELECT
    c.user_id AS user_id,
    p.id AS post_id,
    c.content AS comment_content,
    p.content AS post_content,
    p.title AS post_title
FROM c INNER JOIN p ON p.user_id = c.user_id
`

type ListWithComplexQueryParams struct {
	UserID   sql.NullInt64
	UserID_2 sql.NullInt64
}

type ListWithComplexQueryRow struct {
	UserID         sql.NullInt64
	PostID         int64
	CommentContent sql.NullString
	PostContent    sql.NullString
	PostTitle      string
}

func (q *Queries) ListWithComplexQuery(ctx context.Context, arg ListWithComplexQueryParams) ([]ListWithComplexQueryRow, error) {
	rows, err := q.db.QueryContext(ctx, listWithComplexQuery, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWithComplexQueryRow{}
	for rows.Next() {
		var i ListWithComplexQueryRow
		if err := rows.Scan(
			&i.UserID,
			&i.PostID,
			&i.CommentContent,
			&i.PostContent,
			&i.PostTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
